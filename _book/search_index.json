[["index.html", "BIO1410 - 2024 - Analyses R Chapter 1 Introduction", " BIO1410 - 2024 - Analyses R Karine Villeneuve Chapter 1 Introduction Ce petit guide à été rédigé à l’intention des élèves du cours BIO1410 afin de familiariser les étudiants à l’analyse de données de séquençage d’amplicons avec R. Avant de débuter toute analyse, il est nécessaire de comprendre les principales fonctionnalités de R. La permière section Introduction à R Studio et R Markdown présente donc très brièvement comment utiliser R Mardown avec R Studio. Par la suite, la section BLAST comprend un petit script R permettant à l’élève d’identifier les 10 genres bactériens les plus abondants dans ses échantillons récoltés sous sa langue ainsi que sur la paume de sa mains. Ce script permet aussi de générer un tableau de données en format comma seperated value (csv) que l’étudiant devra utiliser pour obtenir les séquences d’acides nucléiques à rechercher sur la base de données du National Center for Biotechnology Information (NCBI) avec leur outil Basic Local Alignment Search Tool (BLAST). La section Traitement des fastqs présente ensuite comment les données brutes du séquençage d’amplicon du gène ARNs 16S ont été traitées dans R afin d’obtenir une matrice de l’abondance relative des variants de séquence d’amplicon (ASVs) par échantillon. Finalement, la section Statistiques présente l’ensemble des analyses statistiques réalisées avec R afin de comparer le microbiome des deux régions échantillonner. "],["introduction-à-r-studio-et-r-markdown.html", "Chapter 2 Introduction à R Studio et R Markdown 2.1 Pourquoi utiliser R Markdown 2.2 Utliser R Markdowm", " Chapter 2 Introduction à R Studio et R Markdown 2.1 Pourquoi utiliser R Markdown Plusieurs préfèrent rédiger leurs scripts dans des fichiers de type R Markdown plutôt que R Script pour diverses raions. Je recommande personnellement d’utiliser R Markdown pour les raisons suivantes : Ce type de fichier permet de facilement annoter son script entre les sections de codes qui sont comprises dans un bloc (“chunk” en anglais). Un script bien annoter permet non seulement au scripteur de s’y retrouver facilement mais aussi de partager son code à ses collègues ou même publiquement. En effet, il est de plus en plus commun de retrouver dans les articles scientifiques un lien vers les scripts générés et uilisés par les auteurs de l’article afin d’analyser leurs données. Mais aussi, les blocs de codes permettent d’exécuter seulement certaines sections de code à la fois, ce qui ultimement permet de mofidier puis exécuter seulement ces sections de code sans avoir à re-exécuter l’entièreté du script. 2.2 Utliser R Markdowm La première étape consiste donc à créer un nouveau document de type R Mardown. Pour cela, ouvrez RStudio, puis cliquez sur Fichier. Dans le menu déroulant sélectionner Nouveau Fichier puis R Markdown.... Dans la nouvelle fenêtre vous pouvez donner le titre que vous voulez à votre nouveau document. Par défault le nouveau document affiche une petite introduction ainsi que des exemples tel que sur l’image ci-dessous : Ces informations ne sont pas pertinentes et vous pouvez supprimer l’ensemble du texte sous l’entête (l’entête correspond à la section délimitée par les trois tirets ---). 2.2.1 Bloc de codes Dans R markdown, les lignes de codes à exécuter doivent être comprises dans un bloc de code. Le texte non compris dans un bloc n’est donc pas considéré comme du code, ce qui permet d’annoter minutieusement votre script entre les blocs afin de vous y retrouver facilement. Un bloc de code R doit toujours débuter avec les caractères suivants : ```{r} et se terminer avec les caractères suivant : ```. Un bloc de code ressemble donc à ceci : ```{r} ``` Un bloc de code peut être inséré avec l’une des façons suivantes : le raccourcit clavier : Ctrl + Alt + I tapper manuellement les caractères délimitants (```{r} ``` ) l’onglet Code puis Insert chunk le bouton vert avec le petit c et signe de plus en haut à droite. Un fois votre code rédigé dans le bloc, vous pouvez exécuter l’entièreté du code contenu dans ce block en appuyant sur le bouton vert en haut à droite du code ( ▶ ). Il est possible d’insérer des blocs de code de différents languages de programmation tels que Bash et Python, il suffit de remplacer le r entre les accolades par le nom du programme utilisé. Plusieurs autres options peuvent être appliqués sur les blocs, pour plus d’informations je vous recommande de consulter la documentation disponible sur internet. 2.2.2 Définir le répertoire de travail par défault Généralement, avant de commencer à analyser des données, il faut indiquer à R où se trouve les données sur notre ordinateur. Il existe plusieurs manières de procéder, dont notamment, spécifier au début du script un répertoire/dossier de travail par défault. Pour ce faire, une suffit d’insérer un bloc de code R setup comme celui présenté ci-dessous. Le texte entre les guillemets doit simplement être modifié pour le vrai chemin vers votre répertoire/dossier de travail. Une fois le repertoire de travail définit par défaut de la sorte il n’est pas nécessaire d’inclure le chemin vers les fichiers que l’on veut importer tant qu’il se trouve dans le répertoire spécifié. Cela s’applique aussi à la sauvegarde de tableaux, figures ou autres. ```{r setup} knitr::opts_knit$set(root.dir=&quot;/chemin/vers/le/répertoire/&quot;) ``` 2.2.3 Importer des données Pour importer un fichier en format comma seperated value (csv) dans R on utilise la commande read.csv avec les arguments suivants : file : Spécifier le nom du fichier header : Indiquer si la première ligne de notre tableau correspond au nom des colonnes (valeurs possible TRUE/FALSE) row.names : Indiquer quelle colone de notre tableau correspond au nom des rangés sep : Indiquer quel caractère doit servir de séparateur pour les colonnes check.name : Ne pas systématiquement remplacer le trait d’union par un point (valeurs possible TRUE/FALSE) ```{r} df = read.csv(file = &quot;nom_fichier.csv&quot;, header = TRUE, row.names = 1, sep = &quot;,&quot;, check.names = FALSE) ``` Pour un tableau en format tab delimited on peut utiliser la fonction read.table et spécifier \\t comme séparateur. "],["blast.html", "Chapter 3 BLAST", " Chapter 3 BLAST Vous avez vue en classe une figure représentant l’abondance relative des principaux genres bactéries présents sous la langue ainsi que sur la paume de la main dominante de chacun des scientifiques de votre classe. Vous aimeriez maintenant générer une figure similaire à celle présentée en classe mais comprenant uniquement vos échantillons. Pour ce faire, vos démonstrateurs ont rédigé ce petit script R. Il vous suffit de suivre les étapes suivantes : Télécharger le tableau de données (bio1410_2024.csv) à partir du lien suivant LIEN et l’enregistrer sur le bureau (desktop) de l’ordinateur que vous utilisez. Créer un nouveau document de type R markdown. Insérer un nouveau bloc de code R de type setup indiquant le chemin vers le dossier/répertoire de travail par défault. Insérer un nouveau bloc de code R et y copier/coller le script ci-dessous. À la première ligne du code, copier/coller le nom de votre scientifique à partir de la liste des scienfitiques disponible au bas de la page. Attention, assurez-vous de ne pas avoir d’espace entre les guillemets et le nom. Exécuter les commandes en appuyant sur le bouton vert en haut à droite du bloc de code ( ▶ ). # Définir le nom de votre scientifique ma_scientifique = &quot;Abigail A. Salyers&quot; # Importer le tableau de données tableau = read.table(file = &quot;bio1410_2024.csv&quot;, sep=&quot;,&quot;, header=TRUE, check.names=FALSE) # Définir le rang taxonomique d&#39;intérêt taxa_rank = &quot;Genus&quot; # Extraire vos échantillons mes_échantillons = subset(tableau, Scientifique == ma_scientifique &amp; Abundance &gt; 0) # Afin de visualiser uniquementles 10 taxons les plus abondants on utilise ce qu&#39;on appelle une *for loop* ou boucle en français empt_df = list() # On génère une liste vide que l&#39;on viendra populer avec les résultats de la foor loop i = 0 # Ensuite on définit un premier itérateur (de type numérique) qui compte le nombre de loop effectué # Début de la for loop for (région_échantillonnée in unique(mes_échantillons$Region)){ # Cette séquence est le début de la loop où l&#39;itérateur de gauche (région) i = i + 1 # représente chaque item de l&#39;itérateur de droite (mes_échantillons$Région) sample = subset(mes_échantillons, Region == région_échantillonnée) # Générer une nouvelle table de données basée sur la variable définit par l&#39;itérateur total_abundance = aggregate(sample$Abundance, by = list(taxa_rank = sample[[taxa_rank]]), FUN = sum) # Additionner ensemble les ASVs du même genres top =head(total_abundance[order(total_abundance$x, decreasing = T),], n = 10) # filtrer en order croissant pour identifer les 10 plus abondants others_df=sample[!sample[[taxa_rank]] %in% top$taxa_rank,] # identifier les autres genres ne faisant pas partie des 10 plus abonants others_list = others_df[[taxa_rank]] # extraire leur nom du tableau de données dans une liste sample[sample[[taxa_rank]] %in% others_list,][[taxa_rank]] = &quot;Autres&quot; # Renommer leur genre pour Autres empt_df[[i]] = sample # Enregistrer ce nouveau tableau } df = do.call(&quot;rbind&quot;,empt_df) # Combiner les deux tables de données en une seule # Maintenant que nous avons notre tableau de données avec seulement les 10 taxons les plus abondants sous la langue et la main # nous pouvons commencer à travailler sur le graphique. On commence par générer une liste de couleurs associées à chacun des taxons n = nrow(data.frame(unique(df$Genus))) # On calcule le nobre de genre unique que nous avons palette = randomcoloR::distinctColorPalette(n) # On génère une nouvelle palette my_scale = ggplot2::scale_fill_manual(name = as.character(taxa_rank), values = palette, na.translate = FALSE, drop = TRUE, limits = force) # On assigne une couleur à chacun de nos genres uniques # Nous pouvons finalement générer le graphique graphique = ggplot2::ggplot(df, aes(x = Region, weight = Abundance, fill = .data[[taxa_rank]])) + facet_grid(~ Region, scales = &quot;free&quot;) + geom_bar() + labs(y = &quot;Abondance relative (%)&quot;) + scale_y_continuous(expand = c(0,0)) + theme_classic() + theme(text = element_text(size = 12), strip.text.x = element_blank(), plot.title = element_text(hjust = 0.5, margin = margin(0, 0, 50, 0))) + guides(fill = guide_legend(title = &quot;Genre&quot;, title.position = &quot;top&quot;)) + my_scale graphique # visualiser le graphique produit # Enregistrer en format coma separeted value (csv) votre tableau d&#39;abondance write.csv(df, &quot;df.csv&quot;, quote=FALSE, sep=&quot;,&quot;) Scientifiques A - J K - V Abigail A. Salyers Kalpana Chawla Alice Augusta Ball Khatijah Mohammad Yousoff Ana Roque de Duprey Leone Norwood Farrell Angelina Fanny Hesse Lise Meitner Augusta Ada Byron Lovelace Margaret Elaine Heafield Hamilton Chien-Shiung Wu Marie Maynard Daly Clark Creola Katherine Coleman Johnson Marjory Stephenson Dorothy Hodgkin Mary Golda Ross Dorothy Jean Johnson Vaughan Mary Jackson Elizabeth Bugie Gregory Nettie Stevens Elizabeth Garrett Anderson Rachel Carson Emmanuelle Marie Charpentier Rosalind Elsie Franklin Emmy Klieneberger-Nobel Roseli Ocampo-Friedmann Farah Alibay Ruth Ella Moore Floy Agnes Naranjo Stroud Lee Sally Kristen Ride Frances Joan Estelle Wagner Vera Florence Cooper Rubin Gladys Mae Brown West Jane Goodale Jessie Isabelle Price Johanna Westerdijk June Dalziel Hart Almeida "],["traitement-des-fastqs.html", "Chapter 4 Traitement des fastqs", " Chapter 4 Traitement des fastqs "],["statistiques.html", "Chapter 5 Statistiques", " Chapter 5 Statistiques "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
